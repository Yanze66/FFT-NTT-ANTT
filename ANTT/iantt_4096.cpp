// #include "binary_tower.h"  //to avoid recursive error during compilatin, I fixed the parameter for specific use
#include <ap_int.h>
#include <cstdint>
#include <hls_stream.h>
#include <ap_axi_sdata.h>
#include <stdint.h>
#include<iostream>
#include <sys/types.h>

//#include "s8_conff1.h"
// #include "../common.h"
typedef ap_axis<32,0,0,0> axis32_t;


const ap_int<16> W0[2048] = {
   0,
    2,
    4,
    6,
    8,
   10,
   12,
   14,
   16,
   18,
   20,
   22,
   24,
   26,
   28,
   30,
   32,
   34,
   36,
   38,
   40,
   42,
   44,
   46,
   48,
   50,
   52,
   54,
   56,
   58,
   60,
   62,
   64,
   66,
   68,
   70,
   72,
   74,
   76,
   78,
   80,
   82,
   84,
   86,
   88,
   90,
   92,
   94,
   96,
   98,
  100,
  102,
  104,
  106,
  108,
  110,
  112,
  114,
  116,
  118,
  120,
  122,
  124,
  126,
  128,
  130,
  132,
  134,
  136,
  138,
  140,
  142,
  144,
  146,
  148,
  150,
  152,
  154,
  156,
  158,
  160,
  162,
  164,
  166,
  168,
  170,
  172,
  174,
  176,
  178,
  180,
  182,
  184,
  186,
  188,
  190,
  192,
  194,
  196,
  198,
  200,
  202,
  204,
  206,
  208,
  210,
  212,
  214,
  216,
  218,
  220,
  222,
  224,
  226,
  228,
  230,
  232,
  234,
  236,
  238,
  240,
  242,
  244,
  246,
  248,
  250,
  252,
  254,
  256,
  258,
  260,
  262,
  264,
  266,
  268,
  270,
  272,
  274,
  276,
  278,
  280,
  282,
  284,
  286,
  288,
  290,
  292,
  294,
  296,
  298,
  300,
  302,
  304,
  306,
  308,
  310,
  312,
  314,
  316,
  318,
  320,
  322,
  324,
  326,
  328,
  330,
  332,
  334,
  336,
  338,
  340,
  342,
  344,
  346,
  348,
  350,
  352,
  354,
  356,
  358,
  360,
  362,
  364,
  366,
  368,
  370,
  372,
  374,
  376,
  378,
  380,
  382,
  384,
  386,
  388,
  390,
  392,
  394,
  396,
  398,
  400,
  402,
  404,
  406,
  408,
  410,
  412,
  414,
  416,
  418,
  420,
  422,
  424,
  426,
  428,
  430,
  432,
  434,
  436,
  438,
  440,
  442,
  444,
  446,
  448,
  450,
  452,
  454,
  456,
  458,
  460,
  462,
  464,
  466,
  468,
  470,
  472,
  474,
  476,
  478,
  480,
  482,
  484,
  486,
  488,
  490,
  492,
  494,
  496,
  498,
  500,
  502,
  504,
  506,
  508,
  510,
  512,
  514,
  516,
  518,
  520,
  522,
  524,
  526,
  528,
  530,
  532,
  534,
  536,
  538,
  540,
  542,
  544,
  546,
  548,
  550,
  552,
  554,
  556,
  558,
  560,
  562,
  564,
  566,
  568,
  570,
  572,
  574,
  576,
  578,
  580,
  582,
  584,
  586,
  588,
  590,
  592,
  594,
  596,
  598,
  600,
  602,
  604,
  606,
  608,
  610,
  612,
  614,
  616,
  618,
  620,
  622,
  624,
  626,
  628,
  630,
  632,
  634,
  636,
  638,
  640,
  642,
  644,
  646,
  648,
  650,
  652,
  654,
  656,
  658,
  660,
  662,
  664,
  666,
  668,
  670,
  672,
  674,
  676,
  678,
  680,
  682,
  684,
  686,
  688,
  690,
  692,
  694,
  696,
  698,
  700,
  702,
  704,
  706,
  708,
  710,
  712,
  714,
  716,
  718,
  720,
  722,
  724,
  726,
  728,
  730,
  732,
  734,
  736,
  738,
  740,
  742,
  744,
  746,
  748,
  750,
  752,
  754,
  756,
  758,
  760,
  762,
  764,
  766,
  768,
  770,
  772,
  774,
  776,
  778,
  780,
  782,
  784,
  786,
  788,
  790,
  792,
  794,
  796,
  798,
  800,
  802,
  804,
  806,
  808,
  810,
  812,
  814,
  816,
  818,
  820,
  822,
  824,
  826,
  828,
  830,
  832,
  834,
  836,
  838,
  840,
  842,
  844,
  846,
  848,
  850,
  852,
  854,
  856,
  858,
  860,
  862,
  864,
  866,
  868,
  870,
  872,
  874,
  876,
  878,
  880,
  882,
  884,
  886,
  888,
  890,
  892,
  894,
  896,
  898,
  900,
  902,
  904,
  906,
  908,
  910,
  912,
  914,
  916,
  918,
  920,
  922,
  924,
  926,
  928,
  930,
  932,
  934,
  936,
  938,
  940,
  942,
  944,
  946,
  948,
  950,
  952,
  954,
  956,
  958,
  960,
  962,
  964,
  966,
  968,
  970,
  972,
  974,
  976,
  978,
  980,
  982,
  984,
  986,
  988,
  990,
  992,
  994,
  996,
  998,
 1000,
 1002,
 1004,
 1006,
 1008,
 1010,
 1012,
 1014,
 1016,
 1018,
 1020,
 1022,
 1024,
 1026,
 1028,
 1030,
 1032,
 1034,
 1036,
 1038,
 1040,
 1042,
 1044,
 1046,
 1048,
 1050,
 1052,
 1054,
 1056,
 1058,
 1060,
 1062,
 1064,
 1066,
 1068,
 1070,
 1072,
 1074,
 1076,
 1078,
 1080,
 1082,
 1084,
 1086,
 1088,
 1090,
 1092,
 1094,
 1096,
 1098,
 1100,
 1102,
 1104,
 1106,
 1108,
 1110,
 1112,
 1114,
 1116,
 1118,
 1120,
 1122,
 1124,
 1126,
 1128,
 1130,
 1132,
 1134,
 1136,
 1138,
 1140,
 1142,
 1144,
 1146,
 1148,
 1150,
 1152,
 1154,
 1156,
 1158,
 1160,
 1162,
 1164,
 1166,
 1168,
 1170,
 1172,
 1174,
 1176,
 1178,
 1180,
 1182,
 1184,
 1186,
 1188,
 1190,
 1192,
 1194,
 1196,
 1198,
 1200,
 1202,
 1204,
 1206,
 1208,
 1210,
 1212,
 1214,
 1216,
 1218,
 1220,
 1222,
 1224,
 1226,
 1228,
 1230,
 1232,
 1234,
 1236,
 1238,
 1240,
 1242,
 1244,
 1246,
 1248,
 1250,
 1252,
 1254,
 1256,
 1258,
 1260,
 1262,
 1264,
 1266,
 1268,
 1270,
 1272,
 1274,
 1276,
 1278,
 1280,
 1282,
 1284,
 1286,
 1288,
 1290,
 1292,
 1294,
 1296,
 1298,
 1300,
 1302,
 1304,
 1306,
 1308,
 1310,
 1312,
 1314,
 1316,
 1318,
 1320,
 1322,
 1324,
 1326,
 1328,
 1330,
 1332,
 1334,
 1336,
 1338,
 1340,
 1342,
 1344,
 1346,
 1348,
 1350,
 1352,
 1354,
 1356,
 1358,
 1360,
 1362,
 1364,
 1366,
 1368,
 1370,
 1372,
 1374,
 1376,
 1378,
 1380,
 1382,
 1384,
 1386,
 1388,
 1390,
 1392,
 1394,
 1396,
 1398,
 1400,
 1402,
 1404,
 1406,
 1408,
 1410,
 1412,
 1414,
 1416,
 1418,
 1420,
 1422,
 1424,
 1426,
 1428,
 1430,
 1432,
 1434,
 1436,
 1438,
 1440,
 1442,
 1444,
 1446,
 1448,
 1450,
 1452,
 1454,
 1456,
 1458,
 1460,
 1462,
 1464,
 1466,
 1468,
 1470,
 1472,
 1474,
 1476,
 1478,
 1480,
 1482,
 1484,
 1486,
 1488,
 1490,
 1492,
 1494,
 1496,
 1498,
 1500,
 1502,
 1504,
 1506,
 1508,
 1510,
 1512,
 1514,
 1516,
 1518,
 1520,
 1522,
 1524,
 1526,
 1528,
 1530,
 1532,
 1534,
 1536,
 1538,
 1540,
 1542,
 1544,
 1546,
 1548,
 1550,
 1552,
 1554,
 1556,
 1558,
 1560,
 1562,
 1564,
 1566,
 1568,
 1570,
 1572,
 1574,
 1576,
 1578,
 1580,
 1582,
 1584,
 1586,
 1588,
 1590,
 1592,
 1594,
 1596,
 1598,
 1600,
 1602,
 1604,
 1606,
 1608,
 1610,
 1612,
 1614,
 1616,
 1618,
 1620,
 1622,
 1624,
 1626,
 1628,
 1630,
 1632,
 1634,
 1636,
 1638,
 1640,
 1642,
 1644,
 1646,
 1648,
 1650,
 1652,
 1654,
 1656,
 1658,
 1660,
 1662,
 1664,
 1666,
 1668,
 1670,
 1672,
 1674,
 1676,
 1678,
 1680,
 1682,
 1684,
 1686,
 1688,
 1690,
 1692,
 1694,
 1696,
 1698,
 1700,
 1702,
 1704,
 1706,
 1708,
 1710,
 1712,
 1714,
 1716,
 1718,
 1720,
 1722,
 1724,
 1726,
 1728,
 1730,
 1732,
 1734,
 1736,
 1738,
 1740,
 1742,
 1744,
 1746,
 1748,
 1750,
 1752,
 1754,
 1756,
 1758,
 1760,
 1762,
 1764,
 1766,
 1768,
 1770,
 1772,
 1774,
 1776,
 1778,
 1780,
 1782,
 1784,
 1786,
 1788,
 1790,
 1792,
 1794,
 1796,
 1798,
 1800,
 1802,
 1804,
 1806,
 1808,
 1810,
 1812,
 1814,
 1816,
 1818,
 1820,
 1822,
 1824,
 1826,
 1828,
 1830,
 1832,
 1834,
 1836,
 1838,
 1840,
 1842,
 1844,
 1846,
 1848,
 1850,
 1852,
 1854,
 1856,
 1858,
 1860,
 1862,
 1864,
 1866,
 1868,
 1870,
 1872,
 1874,
 1876,
 1878,
 1880,
 1882,
 1884,
 1886,
 1888,
 1890,
 1892,
 1894,
 1896,
 1898,
 1900,
 1902,
 1904,
 1906,
 1908,
 1910,
 1912,
 1914,
 1916,
 1918,
 1920,
 1922,
 1924,
 1926,
 1928,
 1930,
 1932,
 1934,
 1936,
 1938,
 1940,
 1942,
 1944,
 1946,
 1948,
 1950,
 1952,
 1954,
 1956,
 1958,
 1960,
 1962,
 1964,
 1966,
 1968,
 1970,
 1972,
 1974,
 1976,
 1978,
 1980,
 1982,
 1984,
 1986,
 1988,
 1990,
 1992,
 1994,
 1996,
 1998,
 2000,
 2002,
 2004,
 2006,
 2008,
 2010,
 2012,
 2014,
 2016,
 2018,
 2020,
 2022,
 2024,
 2026,
 2028,
 2030,
 2032,
 2034,
 2036,
 2038,
 2040,
 2042,
 2044,
 2046,
 2048,
 2050,
 2052,
 2054,
 2056,
 2058,
 2060,
 2062,
 2064,
 2066,
 2068,
 2070,
 2072,
 2074,
 2076,
 2078,
 2080,
 2082,
 2084,
 2086,
 2088,
 2090,
 2092,
 2094,
 2096,
 2098,
 2100,
 2102,
 2104,
 2106,
 2108,
 2110,
 2112,
 2114,
 2116,
 2118,
 2120,
 2122,
 2124,
 2126,
 2128,
 2130,
 2132,
 2134,
 2136,
 2138,
 2140,
 2142,
 2144,
 2146,
 2148,
 2150,
 2152,
 2154,
 2156,
 2158,
 2160,
 2162,
 2164,
 2166,
 2168,
 2170,
 2172,
 2174,
 2176,
 2178,
 2180,
 2182,
 2184,
 2186,
 2188,
 2190,
 2192,
 2194,
 2196,
 2198,
 2200,
 2202,
 2204,
 2206,
 2208,
 2210,
 2212,
 2214,
 2216,
 2218,
 2220,
 2222,
 2224,
 2226,
 2228,
 2230,
 2232,
 2234,
 2236,
 2238,
 2240,
 2242,
 2244,
 2246,
 2248,
 2250,
 2252,
 2254,
 2256,
 2258,
 2260,
 2262,
 2264,
 2266,
 2268,
 2270,
 2272,
 2274,
 2276,
 2278,
 2280,
 2282,
 2284,
 2286,
 2288,
 2290,
 2292,
 2294,
 2296,
 2298,
 2300,
 2302,
 2304,
 2306,
 2308,
 2310,
 2312,
 2314,
 2316,
 2318,
 2320,
 2322,
 2324,
 2326,
 2328,
 2330,
 2332,
 2334,
 2336,
 2338,
 2340,
 2342,
 2344,
 2346,
 2348,
 2350,
 2352,
 2354,
 2356,
 2358,
 2360,
 2362,
 2364,
 2366,
 2368,
 2370,
 2372,
 2374,
 2376,
 2378,
 2380,
 2382,
 2384,
 2386,
 2388,
 2390,
 2392,
 2394,
 2396,
 2398,
 2400,
 2402,
 2404,
 2406,
 2408,
 2410,
 2412,
 2414,
 2416,
 2418,
 2420,
 2422,
 2424,
 2426,
 2428,
 2430,
 2432,
 2434,
 2436,
 2438,
 2440,
 2442,
 2444,
 2446,
 2448,
 2450,
 2452,
 2454,
 2456,
 2458,
 2460,
 2462,
 2464,
 2466,
 2468,
 2470,
 2472,
 2474,
 2476,
 2478,
 2480,
 2482,
 2484,
 2486,
 2488,
 2490,
 2492,
 2494,
 2496,
 2498,
 2500,
 2502,
 2504,
 2506,
 2508,
 2510,
 2512,
 2514,
 2516,
 2518,
 2520,
 2522,
 2524,
 2526,
 2528,
 2530,
 2532,
 2534,
 2536,
 2538,
 2540,
 2542,
 2544,
 2546,
 2548,
 2550,
 2552,
 2554,
 2556,
 2558,
 2560,
 2562,
 2564,
 2566,
 2568,
 2570,
 2572,
 2574,
 2576,
 2578,
 2580,
 2582,
 2584,
 2586,
 2588,
 2590,
 2592,
 2594,
 2596,
 2598,
 2600,
 2602,
 2604,
 2606,
 2608,
 2610,
 2612,
 2614,
 2616,
 2618,
 2620,
 2622,
 2624,
 2626,
 2628,
 2630,
 2632,
 2634,
 2636,
 2638,
 2640,
 2642,
 2644,
 2646,
 2648,
 2650,
 2652,
 2654,
 2656,
 2658,
 2660,
 2662,
 2664,
 2666,
 2668,
 2670,
 2672,
 2674,
 2676,
 2678,
 2680,
 2682,
 2684,
 2686,
 2688,
 2690,
 2692,
 2694,
 2696,
 2698,
 2700,
 2702,
 2704,
 2706,
 2708,
 2710,
 2712,
 2714,
 2716,
 2718,
 2720,
 2722,
 2724,
 2726,
 2728,
 2730,
 2732,
 2734,
 2736,
 2738,
 2740,
 2742,
 2744,
 2746,
 2748,
 2750,
 2752,
 2754,
 2756,
 2758,
 2760,
 2762,
 2764,
 2766,
 2768,
 2770,
 2772,
 2774,
 2776,
 2778,
 2780,
 2782,
 2784,
 2786,
 2788,
 2790,
 2792,
 2794,
 2796,
 2798,
 2800,
 2802,
 2804,
 2806,
 2808,
 2810,
 2812,
 2814,
 2816,
 2818,
 2820,
 2822,
 2824,
 2826,
 2828,
 2830,
 2832,
 2834,
 2836,
 2838,
 2840,
 2842,
 2844,
 2846,
 2848,
 2850,
 2852,
 2854,
 2856,
 2858,
 2860,
 2862,
 2864,
 2866,
 2868,
 2870,
 2872,
 2874,
 2876,
 2878,
 2880,
 2882,
 2884,
 2886,
 2888,
 2890,
 2892,
 2894,
 2896,
 2898,
 2900,
 2902,
 2904,
 2906,
 2908,
 2910,
 2912,
 2914,
 2916,
 2918,
 2920,
 2922,
 2924,
 2926,
 2928,
 2930,
 2932,
 2934,
 2936,
 2938,
 2940,
 2942,
 2944,
 2946,
 2948,
 2950,
 2952,
 2954,
 2956,
 2958,
 2960,
 2962,
 2964,
 2966,
 2968,
 2970,
 2972,
 2974,
 2976,
 2978,
 2980,
 2982,
 2984,
 2986,
 2988,
 2990,
 2992,
 2994,
 2996,
 2998,
 3000,
 3002,
 3004,
 3006,
 3008,
 3010,
 3012,
 3014,
 3016,
 3018,
 3020,
 3022,
 3024,
 3026,
 3028,
 3030,
 3032,
 3034,
 3036,
 3038,
 3040,
 3042,
 3044,
 3046,
 3048,
 3050,
 3052,
 3054,
 3056,
 3058,
 3060,
 3062,
 3064,
 3066,
 3068,
 3070,
 3072,
 3074,
 3076,
 3078,
 3080,
 3082,
 3084,
 3086,
 3088,
 3090,
 3092,
 3094,
 3096,
 3098,
 3100,
 3102,
 3104,
 3106,
 3108,
 3110,
 3112,
 3114,
 3116,
 3118,
 3120,
 3122,
 3124,
 3126,
 3128,
 3130,
 3132,
 3134,
 3136,
 3138,
 3140,
 3142,
 3144,
 3146,
 3148,
 3150,
 3152,
 3154,
 3156,
 3158,
 3160,
 3162,
 3164,
 3166,
 3168,
 3170,
 3172,
 3174,
 3176,
 3178,
 3180,
 3182,
 3184,
 3186,
 3188,
 3190,
 3192,
 3194,
 3196,
 3198,
 3200,
 3202,
 3204,
 3206,
 3208,
 3210,
 3212,
 3214,
 3216,
 3218,
 3220,
 3222,
 3224,
 3226,
 3228,
 3230,
 3232,
 3234,
 3236,
 3238,
 3240,
 3242,
 3244,
 3246,
 3248,
 3250,
 3252,
 3254,
 3256,
 3258,
 3260,
 3262,
 3264,
 3266,
 3268,
 3270,
 3272,
 3274,
 3276,
 3278,
 3280,
 3282,
 3284,
 3286,
 3288,
 3290,
 3292,
 3294,
 3296,
 3298,
 3300,
 3302,
 3304,
 3306,
 3308,
 3310,
 3312,
 3314,
 3316,
 3318,
 3320,
 3322,
 3324,
 3326,
 3328,
 3330,
 3332,
 3334,
 3336,
 3338,
 3340,
 3342,
 3344,
 3346,
 3348,
 3350,
 3352,
 3354,
 3356,
 3358,
 3360,
 3362,
 3364,
 3366,
 3368,
 3370,
 3372,
 3374,
 3376,
 3378,
 3380,
 3382,
 3384,
 3386,
 3388,
 3390,
 3392,
 3394,
 3396,
 3398,
 3400,
 3402,
 3404,
 3406,
 3408,
 3410,
 3412,
 3414,
 3416,
 3418,
 3420,
 3422,
 3424,
 3426,
 3428,
 3430,
 3432,
 3434,
 3436,
 3438,
 3440,
 3442,
 3444,
 3446,
 3448,
 3450,
 3452,
 3454,
 3456,
 3458,
 3460,
 3462,
 3464,
 3466,
 3468,
 3470,
 3472,
 3474,
 3476,
 3478,
 3480,
 3482,
 3484,
 3486,
 3488,
 3490,
 3492,
 3494,
 3496,
 3498,
 3500,
 3502,
 3504,
 3506,
 3508,
 3510,
 3512,
 3514,
 3516,
 3518,
 3520,
 3522,
 3524,
 3526,
 3528,
 3530,
 3532,
 3534,
 3536,
 3538,
 3540,
 3542,
 3544,
 3546,
 3548,
 3550,
 3552,
 3554,
 3556,
 3558,
 3560,
 3562,
 3564,
 3566,
 3568,
 3570,
 3572,
 3574,
 3576,
 3578,
 3580,
 3582,
 3584,
 3586,
 3588,
 3590,
 3592,
 3594,
 3596,
 3598,
 3600,
 3602,
 3604,
 3606,
 3608,
 3610,
 3612,
 3614,
 3616,
 3618,
 3620,
 3622,
 3624,
 3626,
 3628,
 3630,
 3632,
 3634,
 3636,
 3638,
 3640,
 3642,
 3644,
 3646,
 3648,
 3650,
 3652,
 3654,
 3656,
 3658,
 3660,
 3662,
 3664,
 3666,
 3668,
 3670,
 3672,
 3674,
 3676,
 3678,
 3680,
 3682,
 3684,
 3686,
 3688,
 3690,
 3692,
 3694,
 3696,
 3698,
 3700,
 3702,
 3704,
 3706,
 3708,
 3710,
 3712,
 3714,
 3716,
 3718,
 3720,
 3722,
 3724,
 3726,
 3728,
 3730,
 3732,
 3734,
 3736,
 3738,
 3740,
 3742,
 3744,
 3746,
 3748,
 3750,
 3752,
 3754,
 3756,
 3758,
 3760,
 3762,
 3764,
 3766,
 3768,
 3770,
 3772,
 3774,
 3776,
 3778,
 3780,
 3782,
 3784,
 3786,
 3788,
 3790,
 3792,
 3794,
 3796,
 3798,
 3800,
 3802,
 3804,
 3806,
 3808,
 3810,
 3812,
 3814,
 3816,
 3818,
 3820,
 3822,
 3824,
 3826,
 3828,
 3830,
 3832,
 3834,
 3836,
 3838,
 3840,
 3842,
 3844,
 3846,
 3848,
 3850,
 3852,
 3854,
 3856,
 3858,
 3860,
 3862,
 3864,
 3866,
 3868,
 3870,
 3872,
 3874,
 3876,
 3878,
 3880,
 3882,
 3884,
 3886,
 3888,
 3890,
 3892,
 3894,
 3896,
 3898,
 3900,
 3902,
 3904,
 3906,
 3908,
 3910,
 3912,
 3914,
 3916,
 3918,
 3920,
 3922,
 3924,
 3926,
 3928,
 3930,
 3932,
 3934,
 3936,
 3938,
 3940,
 3942,
 3944,
 3946,
 3948,
 3950,
 3952,
 3954,
 3956,
 3958,
 3960,
 3962,
 3964,
 3966,
 3968,
 3970,
 3972,
 3974,
 3976,
 3978,
 3980,
 3982,
 3984,
 3986,
 3988,
 3990,
 3992,
 3994,
 3996,
 3998,
 4000,
 4002,
 4004,
 4006,
 4008,
 4010,
 4012,
 4014,
 4016,
 4018,
 4020,
 4022,
 4024,
 4026,
 4028,
 4030,
 4032,
 4034,
 4036,
 4038,
 4040,
 4042,
 4044,
 4046,
 4048,
 4050,
 4052,
 4054,
 4056,
 4058,
 4060,
 4062,
 4064,
 4066,
 4068,
 4070,
 4072,
 4074,
 4076,
 4078,
 4080,
 4082,
 4084,
 4086,
 4088,
 4090,
 4092,
 4094};

const ap_int<16> W1[1024] = {
     0,
    13,
    15,
     2,
    81,
    92,
    94,
    83,
   227,
   238,
   236,
   225,
   178,
   191,
   189,
   176,
   233,
   228,
   230,
   235,
   184,
   181,
   183,
   186,
    10,
     7,
     5,
     8,
    91,
    86,
    84,
    89,
   215,
   218,
   216,
   213,
   134,
   139,
   137,
   132,
    52,
    57,
    59,
    54,
   101,
   104,
   106,
   103,
    62,
    51,
    49,
    60,
   111,
    98,
    96,
   109,
   221,
   208,
   210,
   223,
   140,
   129,
   131,
   142,
  4353,
  4364,
  4366,
  4355,
  4432,
  4445,
  4447,
  4434,
  4578,
  4591,
  4589,
  4576,
  4531,
  4542,
  4540,
  4529,
  4584,
  4581,
  4583,
  4586,
  4537,
  4532,
  4534,
  4539,
  4363,
  4358,
  4356,
  4361,
  4442,
  4439,
  4437,
  4440,
  4566,
  4571,
  4569,
  4564,
  4487,
  4490,
  4488,
  4485,
  4405,
  4408,
  4410,
  4407,
  4452,
  4457,
  4459,
  4454,
  4415,
  4402,
  4400,
  4413,
  4462,
  4451,
  4449,
  4460,
  4572,
  4561,
  4563,
  4574,
  4493,
  4480,
  4482,
  4495,
 12803,
 12814,
 12812,
 12801,
 12882,
 12895,
 12893,
 12880,
 13024,
 13037,
 13039,
 13026,
 12977,
 12988,
 12990,
 12979,
 13034,
 13031,
 13029,
 13032,
 12987,
 12982,
 12980,
 12985,
 12809,
 12804,
 12806,
 12811,
 12888,
 12885,
 12887,
 12890,
 13012,
 13017,
 13019,
 13014,
 12933,
 12936,
 12938,
 12935,
 12855,
 12858,
 12856,
 12853,
 12902,
 12907,
 12905,
 12900,
 12861,
 12848,
 12850,
 12863,
 12908,
 12897,
 12899,
 12910,
 13022,
 13011,
 13009,
 13020,
 12943,
 12930,
 12928,
 12941,
  8962,
  8975,
  8973,
  8960,
  9043,
  9054,
  9052,
  9041,
  9185,
  9196,
  9198,
  9187,
  9136,
  9149,
  9151,
  9138,
  9195,
  9190,
  9188,
  9193,
  9146,
  9143,
  9141,
  9144,
  8968,
  8965,
  8967,
  8970,
  9049,
  9044,
  9046,
  9051,
  9173,
  9176,
  9178,
  9175,
  9092,
  9097,
  9099,
  9094,
  9014,
  9019,
  9017,
  9012,
  9063,
  9066,
  9064,
  9061,
  9020,
  9009,
  9011,
  9022,
  9069,
  9056,
  9058,
  9071,
  9183,
  9170,
  9168,
  9181,
  9102,
  9091,
  9089,
  9100,
 37897,
 37892,
 37894,
 37899,
 37976,
 37973,
 37975,
 37978,
 38122,
 38119,
 38117,
 38120,
 38075,
 38070,
 38068,
 38073,
 38112,
 38125,
 38127,
 38114,
 38065,
 38076,
 38078,
 38067,
 37891,
 37902,
 37900,
 37889,
 37970,
 37983,
 37981,
 37968,
 38110,
 38099,
 38097,
 38108,
 38031,
 38018,
 38016,
 38029,
 37949,
 37936,
 37938,
 37951,
 37996,
 37985,
 37987,
 37998,
 37943,
 37946,
 37944,
 37941,
 37990,
 37995,
 37993,
 37988,
 38100,
 38105,
 38107,
 38102,
 38021,
 38024,
 38026,
 38023,
 34056,
 34053,
 34055,
 34058,
 34137,
 34132,
 34134,
 34139,
 34283,
 34278,
 34276,
 34281,
 34234,
 34231,
 34229,
 34232,
 34273,
 34284,
 34286,
 34275,
 34224,
 34237,
 34239,
 34226,
 34050,
 34063,
 34061,
 34048,
 34131,
 34142,
 34140,
 34129,
 34271,
 34258,
 34256,
 34269,
 34190,
 34179,
 34177,
 34188,
 34108,
 34097,
 34099,
 34110,
 34157,
 34144,
 34146,
 34159,
 34102,
 34107,
 34105,
 34100,
 34151,
 34154,
 34152,
 34149,
 34261,
 34264,
 34266,
 34263,
 34180,
 34185,
 34187,
 34182,
 42506,
 42503,
 42501,
 42504,
 42587,
 42582,
 42580,
 42585,
 42729,
 42724,
 42726,
 42731,
 42680,
 42677,
 42679,
 42682,
 42723,
 42734,
 42732,
 42721,
 42674,
 42687,
 42685,
 42672,
 42496,
 42509,
 42511,
 42498,
 42577,
 42588,
 42590,
 42579,
 42717,
 42704,
 42706,
 42719,
 42636,
 42625,
 42627,
 42638,
 42558,
 42547,
 42545,
 42556,
 42607,
 42594,
 42592,
 42605,
 42548,
 42553,
 42555,
 42550,
 42597,
 42600,
 42602,
 42599,
 42711,
 42714,
 42712,
 42709,
 42630,
 42635,
 42633,
 42628,
 46859,
 46854,
 46852,
 46857,
 46938,
 46935,
 46933,
 46936,
 47080,
 47077,
 47079,
 47082,
 47033,
 47028,
 47030,
 47035,
 47074,
 47087,
 47085,
 47072,
 47027,
 47038,
 47036,
 47025,
 46849,
 46860,
 46862,
 46851,
 46928,
 46941,
 46943,
 46930,
 47068,
 47057,
 47059,
 47070,
 46989,
 46976,
 46978,
 46991,
 46911,
 46898,
 46896,
 46909,
 46958,
 46947,
 46945,
 46956,
 46901,
 46904,
 46906,
 46903,
 46948,
 46953,
 46955,
 46950,
 47062,
 47067,
 47065,
 47060,
 46983,
 46986,
 46984,
 46981,
 30727,
 30730,
 30728,
 30725,
 30806,
 30811,
 30809,
 30804,
 30948,
 30953,
 30955,
 30950,
 30901,
 30904,
 30906,
 30903,
 30958,
 30947,
 30945,
 30956,
 30911,
 30898,
 30896,
 30909,
 30733,
 30720,
 30722,
 30735,
 30812,
 30801,
 30803,
 30814,
 30928,
 30941,
 30943,
 30930,
 30849,
 30860,
 30862,
 30851,
 30771,
 30782,
 30780,
 30769,
 30818,
 30831,
 30829,
 30816,
 30777,
 30772,
 30774,
 30779,
 30824,
 30821,
 30823,
 30826,
 30938,
 30935,
 30933,
 30936,
 30859,
 30854,
 30852,
 30857,
 26886,
 26891,
 26889,
 26884,
 26967,
 26970,
 26968,
 26965,
 27109,
 27112,
 27114,
 27111,
 27060,
 27065,
 27067,
 27062,
 27119,
 27106,
 27104,
 27117,
 27070,
 27059,
 27057,
 27068,
 26892,
 26881,
 26883,
 26894,
 26973,
 26960,
 26962,
 26975,
 27089,
 27100,
 27102,
 27091,
 27008,
 27021,
 27023,
 27010,
 26930,
 26943,
 26941,
 26928,
 26979,
 26990,
 26988,
 26977,
 26936,
 26933,
 26935,
 26938,
 26985,
 26980,
 26982,
 26987,
 27099,
 27094,
 27092,
 27097,
 27018,
 27015,
 27013,
 27016,
 18948,
 18953,
 18955,
 18950,
 19029,
 19032,
 19034,
 19031,
 19175,
 19178,
 19176,
 19173,
 19126,
 19131,
 19129,
 19124,
 19181,
 19168,
 19170,
 19183,
 19132,
 19121,
 19123,
 19134,
 18958,
 18947,
 18945,
 18956,
 19039,
 19026,
 19024,
 19037,
 19155,
 19166,
 19164,
 19153,
 19074,
 19087,
 19085,
 19072,
 18992,
 19005,
 19007,
 18994,
 19041,
 19052,
 19054,
 19043,
 19002,
 18999,
 18997,
 19000,
 19051,
 19046,
 19044,
 19049,
 19161,
 19156,
 19158,
 19163,
 19080,
 19077,
 19079,
 19082,
 23301,
 23304,
 23306,
 23303,
 23380,
 23385,
 23387,
 23382,
 23526,
 23531,
 23529,
 23524,
 23479,
 23482,
 23480,
 23477,
 23532,
 23521,
 23523,
 23534,
 23485,
 23472,
 23474,
 23487,
 23311,
 23298,
 23296,
 23309,
 23390,
 23379,
 23377,
 23388,
 23506,
 23519,
 23517,
 23504,
 23427,
 23438,
 23436,
 23425,
 23345,
 23356,
 23358,
 23347,
 23392,
 23405,
 23407,
 23394,
 23355,
 23350,
 23348,
 23353,
 23402,
 23399,
 23397,
 23400,
 23512,
 23509,
 23511,
 23514,
 23433,
 23428,
 23430,
 23435,
 60430,
 60419,
 60417,
 60428,
 60511,
 60498,
 60496,
 60509,
 60653,
 60640,
 60642,
 60655,
 60604,
 60593,
 60595,
 60606,
 60647,
 60650,
 60648,
 60645,
 60598,
 60603,
 60601,
 60596,
 60420,
 60425,
 60427,
 60422,
 60501,
 60504,
 60506,
 60503,
 60633,
 60628,
 60630,
 60635,
 60552,
 60549,
 60551,
 60554,
 60474,
 60471,
 60469,
 60472,
 60523,
 60518,
 60516,
 60521,
 60464,
 60477,
 60479,
 60466,
 60513,
 60524,
 60526,
 60515,
 60627,
 60638,
 60636,
 60625,
 60546,
 60559,
 60557,
 60544,
 64783,
 64770,
 64768,
 64781,
 64862,
 64851,
 64849,
 64860,
 65004,
 64993,
 64995,
 65006,
 64957,
 64944,
 64946,
 64959,
 64998,
 65003,
 65001,
 64996,
 64951,
 64954,
 64952,
 64949,
 64773,
 64776,
 64778,
 64775,
 64852,
 64857,
 64859,
 64854,
 64984,
 64981,
 64983,
 64986,
 64905,
 64900,
 64902,
 64907,
 64827,
 64822,
 64820,
 64825,
 64874,
 64871,
 64869,
 64872,
 64817,
 64828,
 64830,
 64819,
 64864,
 64877,
 64879,
 64866,
 64978,
 64991,
 64989,
 64976,
 64899,
 64910,
 64908,
 64897,
 56845,
 56832,
 56834,
 56847,
 56924,
 56913,
 56915,
 56926,
 57070,
 57059,
 57057,
 57068,
 57023,
 57010,
 57008,
 57021,
 57060,
 57065,
 57067,
 57062,
 57013,
 57016,
 57018,
 57015,
 56839,
 56842,
 56840,
 56837,
 56918,
 56923,
 56921,
 56916,
 57050,
 57047,
 57045,
 57048,
 56971,
 56966,
 56964,
 56969,
 56889,
 56884,
 56886,
 56891,
 56936,
 56933,
 56935,
 56938,
 56883,
 56894,
 56892,
 56881,
 56930,
 56943,
 56941,
 56928,
 57040,
 57053,
 57055,
 57042,
 56961,
 56972,
 56974,
 56963,
 53004,
 52993,
 52995,
 53006,
 53085,
 53072,
 53074,
 53087,
 53231,
 53218,
 53216,
 53229,
 53182,
 53171,
 53169,
 53180,
 53221,
 53224,
 53226,
 53223,
 53172,
 53177,
 53179,
 53174,
 52998,
 53003,
 53001,
 52996,
 53079,
 53082,
 53080,
 53077,
 53211,
 53206,
 53204,
 53209,
 53130,
 53127,
 53125,
 53128,
 53048,
 53045,
 53047,
 53050,
 53097,
 53092,
 53094,
 53099,
 53042,
 53055,
 53053,
 53040,
 53091,
 53102,
 53100,
 53089,
 53201,
 53212,
 53214,
 53203,
 53120,
 53133,
 53135,
 53122
};
const ap_int<16> W2[512] = {
      0,
     2,
   100,
   102,
   184,
   186,
   220,
   222,
   177,
   179,
   213,
   215,
     9,
    11,
   109,
   111,
   210,
   208,
   182,
   180,
   106,
   104,
    14,
    12,
    99,
    97,
     7,
     5,
   219,
   217,
   191,
   189,
 20416,
 20418,
 20388,
 20390,
 20344,
 20346,
 20252,
 20254,
 20337,
 20339,
 20245,
 20247,
 20425,
 20427,
 20397,
 20399,
 20242,
 20240,
 20342,
 20340,
 20394,
 20392,
 20430,
 20428,
 20387,
 20385,
 20423,
 20421,
 20251,
 20249,
 20351,
 20349,
 34112,
 34114,
 34084,
 34086,
 34296,
 34298,
 34204,
 34206,
 34289,
 34291,
 34197,
 34199,
 34121,
 34123,
 34093,
 34095,
 34194,
 34192,
 34294,
 34292,
 34090,
 34088,
 34126,
 34124,
 34083,
 34081,
 34119,
 34117,
 34203,
 34201,
 34303,
 34301,
 51840,
 51842,
 51940,
 51942,
 51768,
 51770,
 51804,
 51806,
 51761,
 51763,
 51797,
 51799,
 51849,
 51851,
 51949,
 51951,
 51794,
 51792,
 51766,
 51764,
 51946,
 51944,
 51854,
 51852,
 51939,
 51937,
 51847,
 51845,
 51803,
 51801,
 51775,
 51773,
  7984,
  7986,
  8020,
  8022,
  8072,
  8074,
  8172,
  8174,
  8065,
  8067,
  8165,
  8167,
  7993,
  7995,
  8029,
  8031,
  8162,
  8160,
  8070,
  8068,
  8026,
  8024,
  7998,
  7996,
  8019,
  8017,
  7991,
  7989,
  8171,
  8169,
  8079,
  8077,
 20720,
 20722,
 20628,
 20630,
 20552,
 20554,
 20524,
 20526,
 20545,
 20547,
 20517,
 20519,
 20729,
 20731,
 20637,
 20639,
 20514,
 20512,
 20550,
 20548,
 20634,
 20632,
 20734,
 20732,
 20627,
 20625,
 20727,
 20725,
 20523,
 20521,
 20559,
 20557,
 39536,
 39538,
 39444,
 39446,
 39624,
 39626,
 39596,
 39598,
 39617,
 39619,
 39589,
 39591,
 39545,
 39547,
 39453,
 39455,
 39586,
 39584,
 39622,
 39620,
 39450,
 39448,
 39550,
 39548,
 39443,
 39441,
 39543,
 39541,
 39595,
 39593,
 39631,
 39629,
 54704,
 54706,
 54740,
 54742,
 54536,
 54538,
 54636,
 54638,
 54529,
 54531,
 54629,
 54631,
 54713,
 54715,
 54749,
 54751,
 54626,
 54624,
 54534,
 54532,
 54746,
 54744,
 54718,
 54716,
 54739,
 54737,
 54711,
 54709,
 54635,
 54633,
 54543,
 54541,
  9488,
  9490,
  9588,
  9590,
  9640,
  9642,
  9676,
  9678,
  9633,
  9635,
  9669,
  9671,
  9497,
  9499,
  9597,
  9599,
  9666,
  9664,
  9638,
  9636,
  9594,
  9592,
  9502,
  9500,
  9587,
  9585,
  9495,
  9493,
  9675,
  9673,
  9647,
  9645,
 27344,
 27346,
 27316,
 27318,
 27240,
 27242,
 27148,
 27150,
 27233,
 27235,
 27141,
 27143,
 27353,
 27355,
 27325,
 27327,
 27138,
 27136,
 27238,
 27236,
 27322,
 27320,
 27358,
 27356,
 27315,
 27313,
 27351,
 27349,
 27147,
 27145,
 27247,
 27245,
 41040,
 41042,
 41012,
 41014,
 41192,
 41194,
 41100,
 41102,
 41185,
 41187,
 41093,
 41095,
 41049,
 41051,
 41021,
 41023,
 41090,
 41088,
 41190,
 41188,
 41018,
 41016,
 41054,
 41052,
 41011,
 41009,
 41047,
 41045,
 41099,
 41097,
 41199,
 41197,
 61328,
 61330,
 61428,
 61430,
 61224,
 61226,
 61260,
 61262,
 61217,
 61219,
 61253,
 61255,
 61337,
 61339,
 61437,
 61439,
 61250,
 61248,
 61222,
 61220,
 61434,
 61432,
 61342,
 61340,
 61427,
 61425,
 61335,
 61333,
 61259,
 61257,
 61231,
 61229,
 14880,
 14882,
 14916,
 14918,
 15000,
 15002,
 15100,
 15102,
 14993,
 14995,
 15093,
 15095,
 14889,
 14891,
 14925,
 14927,
 15090,
 15088,
 14998,
 14996,
 14922,
 14920,
 14894,
 14892,
 14915,
 14913,
 14887,
 14885,
 15099,
 15097,
 15007,
 15005,
 30176,
 30178,
 30084,
 30086,
 30040,
 30042,
 30012,
 30014,
 30033,
 30035,
 30005,
 30007,
 30185,
 30187,
 30093,
 30095,
 30002,
 30000,
 30038,
 30036,
 30090,
 30088,
 30190,
 30188,
 30083,
 30081,
 30183,
 30181,
 30011,
 30009,
 30047,
 30045,
 48992,
 48994,
 48900,
 48902,
 49112,
 49114,
 49084,
 49086,
 49105,
 49107,
 49077,
 49079,
 49001,
 49003,
 48909,
 48911,
 49074,
 49072,
 49110,
 49108,
 48906,
 48904,
 49006,
 49004,
 48899,
 48897,
 48999,
 48997,
 49083,
 49081,
 49119,
 49117,
 61600,
 61602,
 61636,
 61638,
 61464,
 61466,
 61564,
 61566,
 61457,
 61459,
 61557,
 61559,
 61609,
 61611,
 61645,
 61647,
 61554,
 61552,
 61462,
 61460,
 61642,
 61640,
 61614,
 61612,
 61635,
 61633,
 61607,
 61605,
 61563,
 61561,
 61471,
 61469
};

const ap_int<16> W3[256] = {
      0,
     7,
   106,
   109,
   101,
    98,
    15,
     8,
   110,
   105,
     4,
     3,
    11,
    12,
    97,
   102,
 30107,
 30108,
 30193,
 30198,
 30206,
 30201,
 30100,
 30099,
 30197,
 30194,
 30111,
 30104,
 30096,
 30103,
 30202,
 30205,
 41142,
 41137,
 41180,
 41179,
 41171,
 41172,
 41145,
 41150,
 41176,
 41183,
 41138,
 41141,
 41149,
 41146,
 41175,
 41168,
 54573,
 54570,
 54599,
 54592,
 54600,
 54607,
 54562,
 54565,
 54595,
 54596,
 54569,
 54574,
 54566,
 54561,
 54604,
 54603,
 23551,
 23544,
 23445,
 23442,
 23450,
 23453,
 23536,
 23543,
 23441,
 23446,
 23547,
 23548,
 23540,
 23539,
 23454,
 23449,
 11876,
 11875,
 11790,
 11785,
 11777,
 11782,
 11883,
 11884,
 11786,
 11789,
 11872,
 11879,
 11887,
 11880,
 11781,
 11778,
 64329,
 64334,
 64291,
 64292,
 64300,
 64299,
 64326,
 64321,
 64295,
 64288,
 64333,
 64330,
 64322,
 64325,
 64296,
 64303,
 36562,
 36565,
 36536,
 36543,
 36535,
 36528,
 36573,
 36570,
 36540,
 36539,
 36566,
 36561,
 36569,
 36574,
 36531,
 36532,
 59802,
 59805,
 59888,
 59895,
 59903,
 59896,
 59797,
 59794,
 59892,
 59891,
 59806,
 59801,
 59793,
 59798,
 59899,
 59900,
 39937,
 39942,
 40043,
 40044,
 40036,
 40035,
 39950,
 39945,
 40047,
 40040,
 39941,
 39938,
 39946,
 39949,
 40032,
 40039,
 18732,
 18731,
 18758,
 18753,
 18761,
 18766,
 18723,
 18724,
 18754,
 18757,
 18728,
 18735,
 18727,
 18720,
 18765,
 18762,
 15543,
 15536,
 15581,
 15578,
 15570,
 15573,
 15544,
 15551,
 15577,
 15582,
 15539,
 15540,
 15548,
 15547,
 15574,
 15569,
 45669,
 45666,
 45583,
 45576,
 45568,
 45575,
 45674,
 45677,
 45579,
 45580,
 45665,
 45670,
 45678,
 45673,
 45572,
 45571,
 51198,
 51193,
 51092,
 51091,
 51099,
 51100,
 51185,
 51190,
 51088,
 51095,
 51194,
 51197,
 51189,
 51186,
 51103,
 51096,
  4819,
  4820,
  4793,
  4798,
  4790,
  4785,
  4828,
  4827,
  4797,
  4794,
  4823,
  4816,
  4824,
  4831,
  4786,
  4789,
 26440,
 26447,
 26402,
 26405,
 26413,
 26410,
 26439,
 26432,
 26406,
 26401,
 26444,
 26443,
 26435,
 26436,
 26409,
 26414
};

const ap_int<16> W4[128] = {
      0,
     2,
     4,
     6,
     8,
    10,
    12,
    14,
  5349,
  5351,
  5345,
  5347,
  5357,
  5359,
  5353,
  5355,
 10362,
 10360,
 10366,
 10364,
 10354,
 10352,
 10358,
 10356,
 15519,
 15517,
 15515,
 15513,
 15511,
 15509,
 15507,
 15505,
 18941,
 18943,
 18937,
 18939,
 18933,
 18935,
 18929,
 18931,
 23832,
 23834,
 23836,
 23838,
 23824,
 23826,
 23828,
 23830,
 24967,
 24965,
 24963,
 24961,
 24975,
 24973,
 24971,
 24969,
 30050,
 30048,
 30054,
 30052,
 30058,
 30056,
 30062,
 30060,
 36438,
 36436,
 36434,
 36432,
 36446,
 36444,
 36442,
 36440,
 39603,
 39601,
 39607,
 39605,
 39611,
 39609,
 39615,
 39613,
 42540,
 42542,
 42536,
 42538,
 42532,
 42534,
 42528,
 42530,
 45769,
 45771,
 45773,
 45775,
 45761,
 45763,
 45765,
 45767,
 51115,
 51113,
 51119,
 51117,
 51107,
 51105,
 51111,
 51109,
 54094,
 54092,
 54090,
 54088,
 54086,
 54084,
 54082,
 54080,
 61393,
 61395,
 61397,
 61399,
 61401,
 61403,
 61405,
 61407,
 64308,
 64310,
 64304,
 64306,
 64316,
 64318,
 64312,
 64314
};

const ap_int<16> W5[64] = {
       0,
    13,
    15,
     2,
   152,
   149,
   151,
   154,
  5265,
  5276,
  5278,
  5267,
  5129,
  5124,
  5126,
  5131,
 54049,
 54060,
 54062,
 54051,
 54201,
 54196,
 54198,
 54203,
 51120,
 51133,
 51135,
 51122,
 50984,
 50981,
 50983,
 50986,
 64494,
 64483,
 64481,
 64492,
 64374,
 64379,
 64377,
 64372,
 61311,
 61298,
 61296,
 61309,
 61415,
 61418,
 61416,
 61413,
 10447,
 10434,
 10432,
 10445,
 10327,
 10330,
 10328,
 10325,
 15454,
 15443,
 15441,
 15452,
 15558,
 15563,
 15561,
 15556
};

const ap_int<16> W6[32] = {
          0,
     2,
    71,
    69,
   137,
   139,
   206,
   204,
  5369,
  5371,
  5310,
  5308,
  5232,
  5234,
  5175,
  5173,
 10334,
 10332,
 10265,
 10267,
 10455,
 10453,
 10384,
 10386,
 15527,
 15525,
 15584,
 15586,
 15406,
 15404,
 15465,
 15467
};

const ap_int<16> W7[16] = {
           0,
  229,
  216,
   61,
  203,
   46,
   19,
  246,
 5247,
 5274,
 5287,
 5186,
 5300,
 5201,
 5228,
 5257
};

const ap_int<16> W8[8] = {
           0,
  2,
  4,
  6,
  8,
 10,
 12,
 14
};

const ap_int<16> W9[4] = {
           0,
 13,
 15,
  2
};

const ap_int<16> W10[2] = {
           0,
 
  2
};

const ap_int<16> W11[1] = {
           0
};
inline ap_uint<4> b_mul_alpha_u4(ap_uint<4> a) {
	#pragma HLS INLINE
    ap_uint<4> res;
    res[0] = a[2];
    res[1] = a[3];
    res[2] = a[0] ^ a[3];
    res[3] = a[1] ^ a[2] ^ a[3];
    return res;
}

// Multiply by alpha for 8-bit input
inline ap_uint<8> b_mul_alpha_u8(ap_uint<8> a) {
#pragma HLS INLINE
    ap_uint<8> res;
    res[0] = a[4];
    res[1] = a[5];
    res[2] = a[6];
    res[3] = a[7];
    res[4] = a[0] ^ a[6];
    res[5] = a[1] ^ a[7];
    res[6] = a[2] ^ a[4] ^ a[7];
    res[7] = a[3] ^ a[5] ^ a[6] ^ a[7];
    return res;
}

// Multiply by alpha for 16-bit input using 8-bit alpha function
inline ap_uint<16> b_mul_alpha_u16(ap_uint<16> a) {
#pragma HLS INLINE
    ap_uint<8> a0 = a;
    ap_uint<8> a1 = a >> 8;
    return (ap_uint<16>)((a0 ^ b_mul_alpha_u8(a1)) | (a1 << 8));
}

// Multiply two 4-bit inputs in binary field
inline ap_uint<4> b_mul_u4(ap_uint<4> a, ap_uint<4> b) {
#pragma HLS INLINE
    ap_uint<4> res;
    res[0] = (a[0] & b[0]) ^ (a[1] & b[1]) ^ (a[2] & b[2]) ^ (a[3] & b[3]);
    res[1] = (a[1] & b[0]) ^ (a[0] & b[1]) ^ (a[1] & b[1]) ^ (a[3] & b[2]) ^ (a[2] & b[3]) ^ (a[3] & b[3]);
    res[2] = (a[2] & b[0]) ^ (a[3] & b[1]) ^ (a[0] & b[2]) ^ (a[3] & b[2]) ^ (a[1] & b[3]) ^ (a[2] & b[3]) ^ (a[3] & b[3]);
    res[3] = (a[3] & b[0]) ^ (a[2] & b[1]) ^ (a[3] & b[1]) ^ (a[1] & b[2]) ^ (a[2] & b[2]) ^ (a[3] & b[2]) ^
             (a[0] & b[3]) ^ (a[1] & b[3]) ^ (a[2] & b[3]);
    return res;
}

// Multiply two 8-bit inputs using 4-bit units and Karatsuba-like method
inline ap_uint<8> b_mul_u8(ap_uint<8> a, ap_uint<8> b) {
#pragma HLS INLINE
    ap_uint<4> a0 = a;
    ap_uint<4> a1 = a >> 4;
    ap_uint<4> b0 = b;
    ap_uint<4> b1 = b >> 4;
    ap_uint<4> z0 = b_mul_u4(a0, b0);
    ap_uint<4> z1 = b_mul_u4(a0 ^ a1, b0 ^ b1);
    ap_uint<4> z2 = b_mul_u4(a1, b1);
    ap_uint<4> low = z0 ^ z2;
    ap_uint<4> high = (z1 ^ z0 ^ z2) ^ b_mul_alpha_u4(z2);
    return (ap_uint<8>)((high, low));
}

// Multiply two 16-bit inputs using 8-bit units and Karatsuba-like method
inline ap_uint<16> b_mul_u16(ap_uint<16> a, ap_uint<16> b) {
#pragma HLS INLINE
    ap_uint<8> a0 = a;
    ap_uint<8> a1 = a >> 8;
    ap_uint<8> b0 = b;
    ap_uint<8> b1 = b >> 8;
    ap_uint<8> z0 = b_mul_u8(a0, b0);
    ap_uint<8> z1 = b_mul_u8(a0 ^ a1, b0 ^ b1);
    ap_uint<8> z2 = b_mul_u8(a1, b1);
    ap_uint<8> low = z0 ^ z2;
    ap_uint<8> high = (z1 ^ z0 ^ z2) ^ b_mul_alpha_u8(z2);
    return (ap_uint<16>)((high, low));
}


//==========================================stages pipelined optimization ============================================//
//=== perfect 6 us stream ==========//
//==================================//
typedef ap_axis<32,0,0,0> axis32_t;
static void stage0_stream(
    hls::stream<axis32_t> &input,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    for (int i = 0; i < size; i++) {
	#pragma HLS PIPELINE II=1
        axis32_t in_x = input.read();
        // uint16_t R = in_x.data & 0xFFFF;  //this is the correct split, but the first input stream is inversed, ie, it receive [1 (L),0 (R)], instead of [0(L),1(R)] thus, we make shuffle here rather than insert a shuffle function before s0
        // uint16_t L = in_x.data >> 16;

		uint16_t R = in_x.data >> 16 ;
        uint16_t L = in_x.data & 0xFFFF;

        ap_uint<16> w = W0[i];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}
static void shuffle_stream01(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 1;
    const int GROUP = 2;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}



static void stage1_stream(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W1[j/2];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        // axis32_t out;
        // out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // output.write(out);
		ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}

static void shuffle_stream12(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 2;
    const int GROUP = 4;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}



static void stage2_stream(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W2[j/4];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

		// ====== stream out ========//
        // axis32_t out;
        // out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // output.write(out);

		//========== fifo out =========//
		ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}

static void shuffle_stream23(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 4;
    const int GROUP = 8;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}


static void stage3_stream(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
	    // hls::stream<axis32_t> &output,

    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W3[j/8];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        // axis32_t out;
        // out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // output.write(out);
		ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}



static void shuffle_stream34(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 8;
    const int GROUP = 16;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}



static void stage4_stream(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
	    // hls::stream<axis32_t> &output,

    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W4[j/16];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        // axis32_t out;
        // out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // output.write(out);
		ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}


static void shuffle_stream45(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 16;
    const int GROUP = 32;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}

static void stage5_stream(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
	    // hls::stream<axis32_t> &output,

    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W5[j/32];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        // axis32_t out;
        // out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // output.write(out);
		ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}


static void shuffle_stream56(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 32;
    const int GROUP = 64;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}

static void stage6_stream(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
	    // hls::stream<axis32_t> &output,

    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W6[j/64];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        // axis32_t out;
        // out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // output.write(out);
		ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}


static void shuffle_stream67(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 64;
    const int GROUP = 128;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}

static void stage7_stream(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
	    // hls::stream<axis32_t> &output,

    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W7[j/128];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        // axis32_t out;
        // out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // output.write(out);
		ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}


static void shuffle_stream78(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 128;
    const int GROUP = 256;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}


static void stage8_stream(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
	    // hls::stream<axis32_t> &output,

    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W8[j/256];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        // axis32_t out;
        // out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // output.write(out);
		ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}




static void shuffle_stream89(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 256;
    const int GROUP = 512;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}

static void stage9_stream(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
	    // hls::stream<axis32_t> &output,
    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W9[j/512];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        // axis32_t out;
        // out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // output.write(out);
		ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}


static void shuffle_stream910(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 512;
    const int GROUP = 1024;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}


static void stage10_stream(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
	    // hls::stream<axis32_t> &output,
    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W10[j/1024];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        // axis32_t out;
        // out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // output.write(out);
		ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        outFifo.write(out);
    }
}

static void shuffle_stream1011(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 1024;
    const int GROUP = 2048;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}


static void stage11_stream(
    hls::stream<ap_uint<32>> &inFifo,
    // hls::stream<ap_uint<32>> &outFifo,
	    hls::stream<axis32_t> &output,
    int size
){
	#pragma HLS INLINE off

    for (int j = 0; j < size; j++) {
	#pragma HLS PIPELINE II=1

        ap_uint<32> v = inFifo.read();
        uint16_t R = v & 0xFFFF;
        uint16_t L = v >> 16;

        ap_uint<16> w = W11[j/2048];
        uint16_t tR = b_mul_u16(R, w);
        uint16_t tL = b_mul_u16(L, (uint16_t)(w ^ 1));

        axis32_t out;
        out.data = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        output.write(out);
		// ap_uint<32> out = ((uint32_t)(tR ^ tL) << 16) | (L ^ R);
        // outFifo.write(out);
    }
}

static void shuffle_stream11last(
    hls::stream<ap_uint<32>> &inFifo,
    hls::stream<ap_uint<32>> &outFifo,
    int size
){
	#pragma HLS INLINE off

    const int BLOCK = 2048;
    const int GROUP = 4096;

    ap_uint<32> localA0[BLOCK], localA1[BLOCK];
    ap_uint<32> localB[BLOCK];

	#pragma HLS ARRAY_PARTITION variable=localA0 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localA1 cyclic factor=16
	#pragma HLS ARRAY_PARTITION variable=localB  cyclic factor=16

    bool ping = 0;

    // 计算组数（要求 size 是 GROUP 的整数倍）
    int groups = size / GROUP;

    // ---- pre-read first A (only if there's at least one group) ----
    if (groups > 0) {
        for (int i = 0; i < BLOCK; i++) {
            #pragma HLS PIPELINE II=1
            localA0[i] = inFifo.read();
        }
    }

    for (int g = 0; g < groups; ++g) {
                #pragma HLS LOOP_TRIPCOUNT avg=4 max=16
        ap_uint<32> *curA  = ping ? localA1 : localA0;
        ap_uint<32> *nextA = ping ? localA0 : localA1;

        // ---- read B and produce first-part outputs (A_high || B_high) ----
        for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
            ap_uint<32> a = curA[i];
            ap_uint<32> b = inFifo.read();         // read B for this position

            uint16_t aL = a & 0xFFFF;
            uint16_t aH = a >> 16;
            uint16_t bL = b & 0xFFFF;
            uint16_t bH = b >> 16;

            outFifo.write(((uint32_t)aH << 16) | bH);
            localB[i] = ((uint32_t)aL << 16) | bL; // store second-part
        }

        // ---- output second-part. If there is a next group, simultaneously preload nextA ----
        if (g + 1 < groups) {
            // there IS a next group -> overlap output B with preload nextA
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
                nextA[i] = inFifo.read();   // overlapped preload for next group's A
            }
        } else {
            // last group -> no preload, just output remaining B
            for (int i = 0; i < BLOCK; i++){
                #pragma HLS PIPELINE II=1
                outFifo.write(localB[i]);
            }
        }

        ping = !ping;
    }
}


extern "C" {
void iantt_4096(
    hls::stream<axis32_t> &input,
    hls::stream<axis32_t> &output,
    int size
) {

    #pragma HLS INTERFACE ap_ctrl_hs port=return
    #pragma HLS INTERFACE axis port=input
    #pragma HLS INTERFACE axis port=output
    #pragma HLS INTERFACE s_axilite port=size bundle=control
    #pragma HLS INTERFACE s_axilite port=return bundle=control

    #pragma HLS DATAFLOW

    // FIFO between stage0 and shuffle
    hls::stream<ap_uint<32>> fifo0toShuf("fifo0toShuf");
    #pragma HLS STREAM variable=fifo0toShuf depth=2048

    // FIFO between shuffle and stage1
    hls::stream<ap_uint<32>> fifoShufTo1("fifoShufTo1");
    #pragma HLS STREAM variable=fifoShufTo1 depth=2048


	 hls::stream<ap_uint<32>> fifo1toShuf("fifo1toShuf");
    #pragma HLS STREAM variable=fifo1toShuf depth=2048

    // FIFO between shuffle and stage2
    hls::stream<ap_uint<32>> fifoShufTo2("fifoShufTo2");
    #pragma HLS STREAM variable=fifoShufTo2 depth=2048

	 hls::stream<ap_uint<32>> fifo2toShuf("fifo2toShuf");
    #pragma HLS STREAM variable=fifo2toShuf depth=2048

    // FIFO between shuffle and stage3
    hls::stream<ap_uint<32>> fifoShufTo3("fifoShufTo3");
    #pragma HLS STREAM variable=fifoShufTo3 depth=2048

	 hls::stream<ap_uint<32>> fifo3toShuf("fifo3toShuf");
    #pragma HLS STREAM variable=fifo3toShuf depth=2048

    // FIFO between shuffle and stage4
    hls::stream<ap_uint<32>> fifoShufTo4("fifoShufTo4");
    #pragma HLS STREAM variable=fifoShufTo4 depth=2048

	 hls::stream<ap_uint<32>> fifo4toShuf("fifo4toShuf");
    #pragma HLS STREAM variable=fifo4toShuf depth=2048

    // FIFO between shuffle and stage5
    hls::stream<ap_uint<32>> fifoShufTo5("fifoShufTo5");
    #pragma HLS STREAM variable=fifoShufTo5 depth=2048

	 hls::stream<ap_uint<32>> fifo5toShuf("fifo5toShuf");
    #pragma HLS STREAM variable=fifo5toShuf depth=2048

    // FIFO between shuffle and stage6
    hls::stream<ap_uint<32>> fifoShufTo6("fifoShufTo6");
    #pragma HLS STREAM variable=fifoShufTo6 depth=2048

	 hls::stream<ap_uint<32>> fifo6toShuf("fifo6toShuf");
    #pragma HLS STREAM variable=fifo6toShuf depth=2048

    // FIFO between shuffle and stage7
    hls::stream<ap_uint<32>> fifoShufTo7("fifoShufTo7");
    #pragma HLS STREAM variable=fifoShufTo7 depth=2048

	 hls::stream<ap_uint<32>> fifo7toShuf("fifo7toShuf");
    #pragma HLS STREAM variable=fifo7toShuf depth=2048

    // FIFO between shuffle and stage8
    hls::stream<ap_uint<32>> fifoShufTo8("fifoShufTo8");
    #pragma HLS STREAM variable=fifoShufTo8 depth=2048

	 hls::stream<ap_uint<32>> fifo8toShuf("fifo8toShuf");
    #pragma HLS STREAM variable=fifo8toShuf depth=2048

    // FIFO between shuffle and stage9
    hls::stream<ap_uint<32>> fifoShufTo9("fifoShufTo9");
    #pragma HLS STREAM variable=fifoShufTo9 depth=2048

	 hls::stream<ap_uint<32>> fifo9toShuf("fifo9toShuf");
    #pragma HLS STREAM variable=fifo9toShuf depth=2048

    // FIFO between shuffle and stage10
    hls::stream<ap_uint<32>> fifoShufTo10("fifoShufTo10");
    #pragma HLS STREAM variable=fifoShufTo10 depth=2048

	 hls::stream<ap_uint<32>> fifo10toShuf("fifo10toShuf");
    #pragma HLS STREAM variable=fifo10toShuf depth=2048

    // FIFO between shuffle and stage10
    hls::stream<ap_uint<32>> fifoShufTo11("fifoShufTo11");
    #pragma HLS STREAM variable=fifoShufTo11 depth=2048

    stage0_stream(input, fifo0toShuf, size);    // 这个函数自带shuffle，也就是反着分拣输入数据，从而免去一次shuffle函数
    shuffle_stream01(fifo0toShuf, fifoShufTo1, size);

    stage1_stream(fifoShufTo1, fifo1toShuf, size);  // 一次计算一次shuffle
	shuffle_stream12(fifo1toShuf, fifoShufTo2, size);
    stage2_stream(fifoShufTo2, fifo2toShuf, size);
	shuffle_stream23(fifo2toShuf, fifoShufTo3, size);
    stage3_stream(fifoShufTo3, fifo3toShuf, size);
	shuffle_stream34(fifo3toShuf, fifoShufTo4, size);
    stage4_stream(fifoShufTo4, fifo4toShuf, size);
	shuffle_stream45(fifo4toShuf, fifoShufTo5, size);
    stage5_stream(fifoShufTo5, fifo5toShuf, size);
	shuffle_stream56(fifo5toShuf, fifoShufTo6, size);
    stage6_stream(fifoShufTo6, fifo6toShuf, size);
	shuffle_stream67(fifo6toShuf, fifoShufTo7, size);
    stage7_stream(fifoShufTo7, fifo7toShuf, size);
	shuffle_stream78(fifo7toShuf, fifoShufTo8, size);
    stage8_stream(fifoShufTo8, fifo8toShuf, size);
	shuffle_stream89(fifo8toShuf, fifoShufTo9, size);
    stage9_stream(fifoShufTo9, fifo9toShuf, size);
	shuffle_stream910(fifo9toShuf, fifoShufTo10, size);
    stage10_stream(fifoShufTo10, fifo10toShuf, size);
	shuffle_stream1011(fifo10toShuf, fifoShufTo11, size);
    stage11_stream(fifoShufTo11, output, size);  // 输出数据格式为[0,2048],[1,2049],...,[2047,4095]    ([left,right])


    }
}


